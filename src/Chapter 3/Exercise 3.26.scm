(define nil '())
(define false #f)
(define (quotient x y) (/ (- x (mod x y)) y))
(define (error message e)
  (print "Error: " message) (print e) false)

(define (make-tree entry left right)
  (list entry left right))
(define entry car)
(define left-branch cadr)
(define right-branch caddr)

(define (make-table same-key?)
  (let ((local-table (cons '*table* (list nil nil nil))))
    (define (adjoin-set record set)
      (define (iter before rest)
        (cond ((null? rest) (append set (list record)))
              ((string=? (entry record) (entry (car rest))) set)
              ((string<? (entry record) (entry (car rest)))
                         (append before (list record) rest))
              (else (iter (append before (list (car rest)))
                          (cdr rest)))))
      (iter nil set))

    (define (tree->list tree)
      (define (copy-to-list subtree result-list)
        (if (null? subtree)
            result-list
            (copy-to-list (left-branch subtree)
                          (cons (entry subtree)
                                (copy-to-list (right-branch subtree)
                                              result-list)))))
      (if (null? (entry tree))
          nil
          (copy-to-list tree nil)))

    (define (list->tree elements)
      (car (partial-tree elements (length elements))))

    (define (partial-tree elts n)
      (if (= n 0)
          (cons nil elts)
          (let ((left-size (quotient (- n 1) 2)))
            (let ((left-result (partial-tree elts left-size)))
              (let ((left-tree (car left-result))
                    (non-left-elts (cdr left-result))
                    (right-size (- n (+ left-size 1))))
                (let ((this-entry (car non-left-elts))
                      (right-result (partial-tree (cdr non-left-elts)
                                                  right-size)))
                  (let ((right-tree (car right-result))
                        (remaining-elts (cdr right-result)))
                    (cons (make-tree this-entry left-tree right-tree)
                          remaining-elts))))))))

    (define (assoc key records)
      (let ((head (if (or (null? records) (null? (car records)))
                      false
                      (car records))))
        (cond ((not head) false)
              ((string=? key (car head)) head)
              ((string<? key (car head)) (assoc key
                                                (left-branch records)))
              (else (assoc key
                          (right-branch records))))))

    (define (lookup keys)
      (define (iter keys subtable)
        (let ((key (car keys))
              (rest-keys (cdr keys))
              (records (cdr subtable)))
          (if (or (not (pair? (entry records)))
                  (null? (entry records)))
              false
              (let ((next (assoc key records)))
                (if next
                    (if (null? rest-keys)
                        (cadr next)
                        (iter rest-keys next))
                    false)))))
      (if (not (list? keys))
          (error "keys is not a list -- LOOKUP" keys)
          (iter keys local-table)))

    (define (insert! keys value)
      (define (iter keys subtable)
        (let ((key (car keys))
              (rest-keys (cdr keys)))
          (let ((next (assoc key (cdr subtable))))
              (if next
                  (if (null? rest-keys)
                      (set-car! (cdr next) value)
                      (iter rest-keys next))
                  (let ((new-record (cons key (list value nil nil))))
                    (let ((new-subtable-list (adjoin-set new-record
                                                         (tree->list (cdr subtable)))))
                      (let ((new-subtable-tree (list->tree new-subtable-list)))
                        (if (null? rest-keys)
                            (set-cdr! subtable new-subtable-tree)
                            (begin (set-cdr! new-record (cons nil (cddr new-record)))
                                   (set-cdr! subtable new-subtable-tree)
                                   (iter rest-keys new-record))))))))))
      (if (not (list? keys))
          (error "keys is not a list -- INSERT!" keys)
          (iter keys local-table))
      'ok)

    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
            ((eq? m 'insert-proc!) insert!)
            (else (error "Unknown operation -- TABLE" m))))
    dispatch))

(define operation-table (make-table equal?))
(define get (operation-table 'lookup-proc))
(define put (operation-table 'insert-proc!))

